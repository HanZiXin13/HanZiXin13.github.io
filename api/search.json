[{"id":"c4c0028f53dfa8eb1982c4248f9ab94a","title":"【SpringBoot】自定义外部配置文件读取","content":"记SpringBoot读取配置文件的坑（自定义元数据）使用的注解@ConfigurationProperties，@ConditionalOnProperty在一次日常写代码中，按着度娘写的代码去读取配置文件中的数据，发现 @ConditionalOnProperty 这个注解总是验证不通过（导致bean注册不上去）。仔细查找一下资料，发现写法并无错误，但就是验证不通过，发现配置文件中不为on就能通过，即使是false也能通过（这里是指字符串）。于是开始一下午的排坑之旅。\n先说结论\n\n\n\n\n\n\n\n\nSpringBoot中读取配置文件，会先给字段打上标识符Tag来识别他是某一个类型，例如有str、seq、map、时间戳等。不同的类型会有不同的默认值，而value为on时，会识别成bool类型，默认值是true，这样和注解@ConditionalOnProperty(havingValue=&quot;on&quot;)中的on自然不相等，也就会一直校验失败。\n\n那么SpringBoot是根据什么来给字段打上标签的呢？经过一下午的查询找到在SpringBoot中有一个叫\tResolver的类，他的一个字段yamlImplicitResolvers里面就存放了字段的校验规则。\n\n首先先看一下校验的源码:\npublic Tag resolve(NodeId kind, String value, boolean implicit) &#123;\n    if (kind &#x3D;&#x3D; NodeId.scalar &amp;&amp; implicit) &#123;\n        final List&lt;ResolverTuple&gt; resolvers;\n        &#x2F;*\n        这里我们可以看到，yamlImplicitResolvers会去取字段的第一个字母做校验\n        *&#x2F;\n        if (value.length() &#x3D;&#x3D; 0) &#123;\n            resolvers &#x3D; yamlImplicitResolvers.get(&#39;\\0&#39;);\n        &#125; else &#123;\n            resolvers &#x3D; yamlImplicitResolvers.get(value.charAt(0));\n        &#125;\n        &#x2F;&#x2F; yamlImplicitResolvers中分null和非null，这里是非null的情况\n        if (resolvers !&#x3D; null) &#123;\n            for (ResolverTuple v : resolvers) &#123;\n                Tag tag &#x3D; v.getTag();\n                Pattern regexp &#x3D; v.getRegexp();\n                &#x2F;&#x2F; 这里会进行一个正则匹配，只有匹配上了才能返回\n                if (regexp.matcher(value).matches()) &#123;\n                    return tag;\n                &#125;\n            &#125;\n        &#125;\n        if (yamlImplicitResolvers.containsKey(null)) &#123;\n            for (ResolverTuple v : yamlImplicitResolvers.get(null)) &#123;\n                Tag tag &#x3D; v.getTag();\n                Pattern regexp &#x3D; v.getRegexp();\n                &#x2F;&#x2F; 同上\n                if (regexp.matcher(value).matches()) &#123;\n                    return tag;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 如果在yamlImplicitResolvers没有查询到结果，那么就返回传进来的kind（一般是str）\n    switch (kind) &#123;\n    case scalar:\n        return Tag.STR;\n    case sequence:\n        return Tag.SEQ;\n    default:\n        return Tag.MAP;\n    &#125;\n&#125;\n根据上面的代码，我们不难得出 yamlImplicitResolvers就是一个Map，里面的key为一个字符，用于匹配字段名，value为正则表达式，只有同时匹配key和value才返回完整的Tag。\n\n注意这里key和value指的是yamlImplicitResolvers对象的key和value，而不是配置文件中的key和value。\n\n列举一些yamlImplicitResolvers中的值：\n\nnull-&gt;[^(?:~|null|Null|NULL| )$,^$]\nF-&gt;[^(?:yes|Yes|YES|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF)$]\nN-&gt;[^(?:yes|Yes|YES|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF)$, ^(?:~|null|Null|NULL| )$]\n(万恶之源)o-&gt;[^(?:yes|Yes|YES|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF)$]\n\n\n\n\n\n\n\n\n注意，配置文件中只有value需要注意写法，如果在@ConfigurationProperties标识的类中定义了字段类型，那么就不会自行转换了（可能）。\n\n\n痛苦记忆\n最开始以为是写法问题，属性值写错了之类的。点进去@ConditionalOnProperty里看了很多遍，很多方法都试过了，发现没有问题。然后试了下官方文档的实例，发现都可以，甚至false都可以，说明这个字段应该是字符串类型的，然后发现只有用on不行，于是猜想是不是SpringBoot自带什么奇怪的转化问题。\n其实在一开始是报的找不到bean这个错，一顿排查找到了带@ConditionalOnProperty的这个方法，猜想打了断点发现根本没创建bean，猜想是不是没通过校验。😂\n然后准备去找，是不是@ConditionalOnProperty里面做了什么奇怪的操作把属性havingValue的值给改掉了，但自己对Spring不算很熟练，只知道SpringAop会对方法代理，执行一个代理方法，这么快想到是因为之前自己写过AOP日志。于是想着去找Spring的方法增强里面找，看看是不是把方法注解给我改东西了。\n首先找到打印日志的类NoSuchBeanDefinitionFailureAnalyzer 通过debug 观察到抛出的异常，但是这个异常仅仅是找不到 bean 所抛出的异常，对我们要找的问题没有什么帮助。在搜索ConditionalOnProperty观察后，在Spring的上下文的ConditionContext中找到了创建 bean 的方法，观察发现在该context中注解的值是正常的为**”on”**。（在OnPropertyCondition的校验类中的getMatchOutcome方法里面可以找到，并且debug发现把匹配结果加入了noMatch集合中，也就是为匹配，说明配置文件读取的有问题。）\n继续观察上下文对象，发现了配置文件中的值为true，这就很神奇了，明明配置文件中写的是on，为什么会变成true呢？（这里的value点进去是Boolean类型）\n\n\n\n\n\n\n\n\n\n\n在context对象中有一个environment对象，里面的propertySources属性里记录了外部数据的详细信息，其中的OriginTrackedMapPropertySource &#123;name=&#39;Config resource &#39;class path resource [application.yaml]&#39; via location &#39;optional:classpath:/&#39;&#39;&#125;对象就是读取我们自己写的配置文件的对象，再去里面找到source属性就可以找到我们自己定义的所有字段包括值\n根本原因到这里，问题似乎一目了然了，显然是SpringBoot在读取配置文件时，根据字段或者值在转成java对应的类型时转出了问题。那么SpringBoot是怎么读取配置文件的呢，度娘了一下，找到了这个类YamlPropertySourceLoader是用于读取yaml文件的，（顺带提一句，这里可以看到yml和yaml是一个文件类型）。随后在核心方法里可以找到调用的OriginTrackedYamlLoader这货的load方法\npublic List&lt;PropertySource&lt;?&gt;&gt; load(String name, Resource resource) throws IOException &#123;\n\tif (!ClassUtils.isPresent(&quot;org.yaml.snakeyaml.Yaml&quot;, getClass().getClassLoader())) &#123;\n\t\tthrow new IllegalStateException(\n\t\t\t\t&quot;Attempted to load &quot; + name + &quot; but snakeyaml was not found on the classpath&quot;);\n\t&#125;\n\t&#x2F;&#x2F; 就在这里\n\tList&lt;Map&lt;String, Object&gt;&gt; loaded &#x3D; new OriginTrackedYamlLoader(resource).load();\n\tif (loaded.isEmpty()) &#123;\n\t\treturn Collections.emptyList();\n\t&#125;\n\tList&lt;PropertySource&lt;?&gt;&gt; propertySources &#x3D; new ArrayList&lt;&gt;(loaded.size());\n\tfor (int i &#x3D; 0; i &lt; loaded.size(); i++) &#123;\n\t\tString documentNumber &#x3D; (loaded.size() !&#x3D; 1) ? &quot; (document #&quot; + i + &quot;)&quot; : &quot;&quot;;\n\t\tpropertySources.add(new OriginTrackedMapPropertySource(name + documentNumber,\n\t\t\t\tCollections.unmodifiableMap(loaded.get(i)), true));\n\t&#125;\n\treturn propertySources;\n&#125;\n在load里面继续调用了YamlProcessor类的process方法\nprivate boolean process(MatchCallback callback, Yaml yaml, Resource resource) &#123;\n\tint count &#x3D; 0;\n\ttry &#123;\n\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\tlogger.debug(&quot;Loading from YAML: &quot; + resource);\n\t\t&#125;\n\t\ttry (Reader reader &#x3D; new UnicodeReader(resource.getInputStream())) &#123;\n\t\t\t&#x2F;&#x2F; 在这里才会加载yaml\n\t\t\tfor (Object object : yaml.loadAll(reader)) &#123;\n\t\t\t\tif (object !&#x3D; null &amp;&amp; process(asMap(object), callback)) &#123;\n\t\t\t\t\tcount++;\n\t\t\t\t\tif (this.resolutionMethod &#x3D;&#x3D; ResolutionMethod.FIRST_FOUND) &#123;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\t\tlogger.debug(&quot;Loaded &quot; + count + &quot; document&quot; + (count &gt; 1 ? &quot;s&quot; : &quot;&quot;) +\n\t\t\t\t\t\t&quot; from YAML resource: &quot; + resource);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tcatch (IOException ex) &#123;\n\t\thandleProcessError(resource, ex);\n\t&#125;\n\treturn (count &gt; 0);\n&#125;\n点进加载方法loadAll看一下，发现这是一个迭代器（还发现配置文件用文件流读取），里面有一个全局对象constructor，暂时不去关心怎么来的，去重写的迭代器里面的next方法发现调用的是constructor对象的getData()方法。在点进去就是本文开头的内容了，这里就不再复述了。\n总结到此，我们明白了SpringBoot读取配置文件的机制，并且了解了配置文件有一些特殊的语义需要注意。这次观察SpringBoot源码告一段落，其实在一开始就大概猜到了是哪里出了问题，但是不清楚为什么会这样，阅读完源码想明白了很多，感觉又有成长了。\n","slug":"【SpringBoot】自定义外部配置文件读取","date":"2022-05-27T07:53:01.000Z","categories_index":"","tags_index":"SpringBoot,Java","author_index":"Xin_Chen"},{"id":"426935cfda214078fe347e2ba79a50b5","title":"【Linux】Linux命令笔记","content":"Linux常用命令开启指定端口firewall-cmd --zone&#x3D;public --add-port&#x3D;8080&#x2F;tcp --permanent\n\n含义：\n–zone\t#作用域\n–add-port&#x3D;8080&#x2F;tcp\t#端口&#x2F;通讯协议\n–permanent\t#永久生效\n查看哪些端口或者服务是开放的firewall-cmd --list-ports\nfirewall-cmd --list-services\n\n重启防火墙firewall-cmd --reload\n\njboss相关命令jboss.master.host\nJBOSS_HOME&#x3D;&#x2F;jboss&#x2F;wildfly-14.0.1.Final\n进入bin目录后执行:\n开启服务(&amp;表示后台启动)\n.&#x2F;standalone.sh&amp;\n\n关闭服务\n.&#x2F;jboss-cli.sh --connect command&#x3D;:shutdown\n\n通过命令行部署war首先使用 ./jboss-cli.sh 进入 Console界面\n部署：\ndeploy\n\n销毁：\nundeploy\n\ndomain模式管理员账号密码admin&#x2F;admin\n组：admin\n凭证：&lt;secret value=&quot;YWRtaW4=&quot; /&gt;\n用户账号密码cargo&#x2F;cargo\n组：user\n凭证：&lt;secret value=&quot;Y2FyZ28=&quot; /&gt;\nJava命令指定 Java 版本：\nupdate-alternatives --config java\nupdate-alternatives --config javac\n\nDocker相关注：\n如果不是使用 root 用户，普通用户需要先授权，\n授权过程如下：\nsudo gpasswd -a $&#123;USER&#125; dockerroot  # 新版docker组名是dockerroot，老版本是docker，如不确定，可以去&#x2F;etc&#x2F;group查看\nnewgrp dockerroot\nsudo systemctl restart docker  # 重启docker\nsudo chmod a+rw &#x2F;var&#x2F;run&#x2F;docker.sock  #给用户授权\n\n访问jbossJDK11 dockerfile编写：\n# jdk依赖于系统\nFROM centos:7.6.1810\n# 创建人和邮箱\nMAINTAINER han &lt;2278461857@qq.com&gt;\n# 创建目录\nRUN mkdir &#x2F;usr&#x2F;local&#x2F;java\n# 把压缩包移到目录下，自动解压\nADD jdk-11.tar.gz &#x2F;usr&#x2F;local&#x2F;java&#x2F;\n# 修改时区\nRUN ln -sf &#x2F;usr&#x2F;share&#x2F;zone&#x2F;info&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime\n# 编辑环境变量\nENV JAVA_HOME &#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk-11.0.13\nENV PATH $JAVA_HOME&#x2F;bin:$PATH\n# VOLUME 指定了临时文件目录为&#x2F;tmp\n# 其效果是在主机 &#x2F;var&#x2F;lib&#x2F;docker 目录下创建了一个临时文件，并链接到容器的&#x2F;tmp\nVOLUME &#x2F;tmp\n\nwildfly dockerfile编写：\n# 依赖于java11\nFROM java:11\n# 创建人和邮箱\nMAINTAINER han &lt;2278461857@qq.com&gt;\n# 创建目录\nRUN mkdir &#x2F;usr&#x2F;local&#x2F;wildfly\n# 移动目录\nCOPY .&#x2F;wildfly-14.0.1.Final &#x2F;usr&#x2F;local&#x2F;wildfly&#x2F;\n# 修改时区\nRUN ln -sf &#x2F;usr&#x2F;share&#x2F;zone&#x2F;info&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime\n# 进入工作目录\nWORKDIR &#x2F;usr&#x2F;local&#x2F;wildfly&#x2F;wildfly-14.0.1.Final&#x2F;bin\n# 开放端口\nEXPOSE 9990\nRUN .&#x2F;domain.sh\n\n主机地址172.17.0.2\nk8s安装和使用首先安装k8s：\nyum install -y etcd kubernetes\n\n修改配置文件：\nvim &#x2F;etc&#x2F;sysconfig&#x2F;docker\n# 将   --selinux-enabled   改为   --selinux-enabled&#x3D;false --insecure-registry gcr.io\nvim &#x2F;etc&#x2F;kubernetes&#x2F;apiserver\n#将  KUBE_ADMISSION_CONTROL  参数中的  ServiceAccount  删除\n\n启动所有服务：\nfor s in etcd docker kube-apiserver kube-controller-manager kube-scheduler kubelet kube-proxy; do systemctl start $s; done\n\nkubeadm init –apiserver-advertise-address&#x3D;192.168.237.138 –image-repository registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers –kubernetes-version v1.17.3 –service-cidr&#x3D;10.96.0.0&#x2F;16 –pod-network-cidr&#x3D;192.168.0.0&#x2F;16\nkubeadm join 192.168.237.138:6443 –token ypj4qv.zojv6yetx417hg5c     –discovery-token-ca-cert-hash sha256:8610f6f786fb73968577862a0094e65a93a017276d1f6f0da1c1b01778b39fc6 \n永不过期的令牌：\nkubeadm join 192.168.237.138:6443 --token 自己的token     --discovery-token-ca-cert-hash sha256:8610f6f786fb73968577862a0094e65a93a017276d1f6f0da1c1b01778b39fc6\n\n\n\n创建pod节点配置文件创建命令：kubectl create -f jboss-rc.yaml\napiVersion: v1\nkind: ReplicationController    # 副本控制器RC\nmetadata:\n  name: jboss                  # RC的名称，全局唯一\nspec:\n  replicas: 1                  # Pod副本的期待数量\n  selector:\n    app: jboss                 # 符合目标的Pod拥有此标签\n  template:                    # 根据此模板创建Pod的副本（实例）\n    metadata:\n      labels:\n        app: jboss             # Pod副本拥有的标签，对应RC的Selector\n    spec:\n      containers:              # Pod内容器的定义部分\n        - name: jboss-master     # 容器的名称\n          image: jboss:master    # 容器对应的Docker image\n          ports:\n          - containerPort: 8080  # 容器应用监听的端口号\n          - containerPort: 8230\n        # env:                 # 注入容器内的环境变量\n        # - name: MYSQL_ROOT_PASSWORD                     \n          # value: &quot;123456&quot;\n\n固定ip：\nannotations:\n       cni.projectcalico.org&#x2F;ipAddrs: &quot;[\\&quot;10.0.113.137\\&quot;]&quot;\n\n\n\n问题访问挂载点出现权限不足目录结构后加上 --privileged=true \n例：\ndocker run -i -t -v &#x2F;jboss&#x2F;:&#x2F;root&#x2F;jboss --privileged&#x3D;true  jboss:master &#x2F;bin&#x2F;bash\n\ndocker启动报错unable to configure the Docker daemon with file可能是由于daemon.json文件里配置的私有文件仓库和配置文件冲突\n几个配置文件：\nEnvironmentFile&#x3D;-&#x2F;run&#x2F;containers&#x2F;registries.conf\nEnvironmentFile&#x3D;-&#x2F;etc&#x2F;sysconfig&#x2F;docker\nEnvironmentFile&#x3D;-&#x2F;etc&#x2F;sysconfig&#x2F;docker-storage\nEnvironmentFile&#x3D;-&#x2F;etc&#x2F;sysconfig&#x2F;docker-network\n\n这次是在 -&#x2F;etc&#x2F;sysconfig&#x2F;docker 里找到冲突\n注：他机访问可能出现报错\n# 修改启动参数，信任私有仓库\nvim &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service\n# 加上--insecure-registry $&#123;192.168.92.134:5000&#125;\n\nk8s node节点会优先读取本地的镜像，而不是去仓库拉取*kubeadm初始化问题pod-network-cidr参数所指向的ip子网不能和主机子网相同！！！！！！！\n即如果您的网络运行在192.168.*.*使用10.0.0.0&#x2F;16\n如果您的网络是10.0.*.*使用192.168.0.0&#x2F;16\n出现ping不通pod的情况修改calico.yaml文件\n修改calico-node的env加上：\n- name: IP_AUTODETECTION_METHOD\n  value: &quot;interface&#x3D;em1&quot;     # em1 是实际网卡\n","slug":"Linux命令笔记","date":"2022-05-27T07:27:22.000Z","categories_index":"","tags_index":"linux","author_index":"Xin_Chen"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-05-26T11:33:49.450Z","categories_index":"","tags_index":"","author_index":"Xin_Chen"}]