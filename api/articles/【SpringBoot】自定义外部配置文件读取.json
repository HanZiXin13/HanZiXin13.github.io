{"title":"【SpringBoot】自定义外部配置文件读取","uid":"c4c0028f53dfa8eb1982c4248f9ab94a","slug":"【SpringBoot】自定义外部配置文件读取","date":"2022-05-27T07:53:01.000Z","updated":"2022-05-27T09:18:46.205Z","comments":true,"path":"api/articles/【SpringBoot】自定义外部配置文件读取.json","keywords":null,"cover":"https://img.zcool.cn/community/0189d45996dc5500000021290a96b8.jpg@1280w_1l_2o_100sh.jpg","content":"<h1 id=\"记SpringBoot读取配置文件的坑（自定义元数据）\"><a href=\"#记SpringBoot读取配置文件的坑（自定义元数据）\" class=\"headerlink\" title=\"记SpringBoot读取配置文件的坑（自定义元数据）\"></a>记SpringBoot读取配置文件的坑（自定义元数据）</h1><p>使用的注解<code>@ConfigurationProperties，@ConditionalOnProperty</code><br>在一次日常写代码中，按着度娘写的代码去读取配置文件中的数据，发现 <code>@ConditionalOnProperty</code> 这个注解总是验证不通过（导致bean注册不上去）。仔细查找一下资料，发现写法并无错误，但就是验证不通过，发现配置文件中不为<strong>on</strong>就能通过，即使是<strong>false</strong>也能通过（这里是指字符串）。于是开始一下午的排坑之旅。</p>\n<h4 id=\"先说结论\"><a href=\"#先说结论\" class=\"headerlink\" title=\"先说结论\"></a>先说结论</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>SpringBoot中读取配置文件，会先给字段打上标识符<strong>Tag</strong>来识别他是某一个类型，例如有<strong>str、seq、map、时间戳等</strong>。不同的类型会有不同的默认值，而value为on时，会识别成<strong>bool</strong>类型，默认值是true，这样和注解<code>@ConditionalOnProperty(havingValue=&quot;on&quot;)</code>中的on自然不相等，也就会一直校验失败。</p></blockquote>\n<ul>\n<li>那么SpringBoot是根据什么来给字段打上标签的呢？<br>经过一下午的查询找到在SpringBoot中有一个叫\t<code>Resolver</code>的类，他的一个字段<code>yamlImplicitResolvers</code>里面就存放了字段的校验规则。</li>\n</ul>\n<p>首先先看一下校验的源码:</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public Tag resolve(NodeId kind, String value, boolean implicit) &#123;\n    if (kind &#x3D;&#x3D; NodeId.scalar &amp;&amp; implicit) &#123;\n        final List&lt;ResolverTuple&gt; resolvers;\n        &#x2F;*\n        这里我们可以看到，yamlImplicitResolvers会去取字段的第一个字母做校验\n        *&#x2F;\n        if (value.length() &#x3D;&#x3D; 0) &#123;\n            resolvers &#x3D; yamlImplicitResolvers.get(&#39;\\0&#39;);\n        &#125; else &#123;\n            resolvers &#x3D; yamlImplicitResolvers.get(value.charAt(0));\n        &#125;\n        &#x2F;&#x2F; yamlImplicitResolvers中分null和非null，这里是非null的情况\n        if (resolvers !&#x3D; null) &#123;\n            for (ResolverTuple v : resolvers) &#123;\n                Tag tag &#x3D; v.getTag();\n                Pattern regexp &#x3D; v.getRegexp();\n                &#x2F;&#x2F; 这里会进行一个正则匹配，只有匹配上了才能返回\n                if (regexp.matcher(value).matches()) &#123;\n                    return tag;\n                &#125;\n            &#125;\n        &#125;\n        if (yamlImplicitResolvers.containsKey(null)) &#123;\n            for (ResolverTuple v : yamlImplicitResolvers.get(null)) &#123;\n                Tag tag &#x3D; v.getTag();\n                Pattern regexp &#x3D; v.getRegexp();\n                &#x2F;&#x2F; 同上\n                if (regexp.matcher(value).matches()) &#123;\n                    return tag;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 如果在yamlImplicitResolvers没有查询到结果，那么就返回传进来的kind（一般是str）\n    switch (kind) &#123;\n    case scalar:\n        return Tag.STR;\n    case sequence:\n        return Tag.SEQ;\n    default:\n        return Tag.MAP;\n    &#125;\n&#125;</code></pre>\n<p>根据上面的代码，我们不难得出 <strong>yamlImplicitResolvers就是一个Map，里面的key为一个字符，用于匹配字段名，value为正则表达式，只有同时匹配key和value才返回完整的Tag</strong>。</p>\n<ul>\n<li>注意这里key和value指的是yamlImplicitResolvers对象的key和value，而不是配置文件中的key和value。</li>\n</ul>\n<p>列举一些yamlImplicitResolvers中的值：</p>\n<ul>\n<li><code>null-&gt;[^(?:~|null|Null|NULL| )$,^$]</code></li>\n<li><code>F-&gt;[^(?:yes|Yes|YES|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF)$]</code></li>\n<li><code>N-&gt;[^(?:yes|Yes|YES|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF)$, ^(?:~|null|Null|NULL| )$]</code></li>\n<li>(<em>万恶之源</em>)<code>o-&gt;[^(?:yes|Yes|YES|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF)$]</code><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意，配置文件中只有value需要注意写法，如果在<code>@ConfigurationProperties</code>标识的类中定义了字段类型，那么就不会自行转换了（可能）。</p></blockquote>\n</li>\n</ul>\n<h4 id=\"痛苦记忆\"><a href=\"#痛苦记忆\" class=\"headerlink\" title=\"痛苦记忆\"></a>痛苦记忆</h4><ol>\n<li>最开始以为是写法问题，属性值写错了之类的。点进去<code>@ConditionalOnProperty</code>里看了很多遍，很多方法都试过了，发现没有问题。然后试了下官方文档的实例，发现都可以，甚至false都可以，说明这个字段应该是字符串类型的，然后发现只有用<strong>on</strong>不行，于是猜想是不是SpringBoot自带什么奇怪的转化问题。</li>\n<li><del>其实在一开始是报的找不到bean这个错，一顿排查找到了带<code>@ConditionalOnProperty</code>的这个方法，猜想打了断点发现根本没创建bean，猜想是不是没通过校验。😂</del></li>\n<li>然后准备去找，是不是<code>@ConditionalOnProperty</code>里面做了什么奇怪的操作把属性<strong>havingValue</strong>的值给改掉了，但自己对Spring不算很熟练，只知道SpringAop会对方法代理，执行一个代理方法，<em>这么快想到是因为之前自己写过AOP日志</em>。于是想着去找Spring的方法增强里面找，看看是不是把方法注解给我改东西了。</li>\n<li>首先找到打印日志的类<code>NoSuchBeanDefinitionFailureAnalyzer</code> 通过debug 观察到抛出的异常，但是这个异常仅仅是找不到 bean 所抛出的异常，对我们要找的问题没有什么帮助。在搜索<code>ConditionalOnProperty</code>观察后，在Spring的上下文的<code>ConditionContext</code>中找到了创建 bean 的方法，观察发现在该context中注解的值是正常的为**”on”**。（在<code>OnPropertyCondition</code>的校验类中的<code>getMatchOutcome</code>方法里面可以找到，并且debug发现把匹配结果加入了<code>noMatch</code>集合中，也就是为匹配，说明配置文件读取的有问题。）</li>\n<li>继续观察上下文对象，发现了配置文件中的值为<strong>true</strong>，这就很神奇了，明明配置文件中写的是<strong>on</strong>，为什么会变成<strong>true</strong>呢？（这里的value点进去是<strong>Boolean</strong>类型）<br><img src=\"https://img-blog.csdnimg.cn/ba86590e717742d589a267d2ad2460bc.png\" alt=\"自己定义的字段和值\"></li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><em>在context对象中有一个<strong>environment</strong>对象，里面的propertySources属性里记录了外部数据的详细信息，其中的<code>OriginTrackedMapPropertySource &#123;name=&#39;Config resource &#39;class path resource [application.yaml]&#39; via location &#39;optional:classpath:/&#39;&#39;&#125;</code>对象就是读取我们自己写的配置文件的对象，再去里面找到<strong>source</strong>属性就可以找到我们自己定义的所有字段包括值</em></p></blockquote>\n<h4 id=\"根本原因\"><a href=\"#根本原因\" class=\"headerlink\" title=\"根本原因\"></a>根本原因</h4><p>到这里，问题似乎一目了然了，<strong>显然是SpringBoot在读取配置文件时，根据字段或者值在转成java对应的类型时转出了问题。</strong><br>那么SpringBoot是怎么读取配置文件的呢，度娘了一下，找到了这个类<code>YamlPropertySourceLoader</code>是用于读取yaml文件的，（顺带提一句，这里可以看到yml和yaml是一个文件类型）。随后在核心方法里可以找到调用的<code>OriginTrackedYamlLoader</code>这货的load方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public List&lt;PropertySource&lt;?&gt;&gt; load(String name, Resource resource) throws IOException &#123;\n\tif (!ClassUtils.isPresent(&quot;org.yaml.snakeyaml.Yaml&quot;, getClass().getClassLoader())) &#123;\n\t\tthrow new IllegalStateException(\n\t\t\t\t&quot;Attempted to load &quot; + name + &quot; but snakeyaml was not found on the classpath&quot;);\n\t&#125;\n\t&#x2F;&#x2F; 就在这里\n\tList&lt;Map&lt;String, Object&gt;&gt; loaded &#x3D; new OriginTrackedYamlLoader(resource).load();\n\tif (loaded.isEmpty()) &#123;\n\t\treturn Collections.emptyList();\n\t&#125;\n\tList&lt;PropertySource&lt;?&gt;&gt; propertySources &#x3D; new ArrayList&lt;&gt;(loaded.size());\n\tfor (int i &#x3D; 0; i &lt; loaded.size(); i++) &#123;\n\t\tString documentNumber &#x3D; (loaded.size() !&#x3D; 1) ? &quot; (document #&quot; + i + &quot;)&quot; : &quot;&quot;;\n\t\tpropertySources.add(new OriginTrackedMapPropertySource(name + documentNumber,\n\t\t\t\tCollections.unmodifiableMap(loaded.get(i)), true));\n\t&#125;\n\treturn propertySources;\n&#125;</code></pre>\n<p>在load里面继续调用了<code>YamlProcessor</code>类的<code>process</code>方法</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private boolean process(MatchCallback callback, Yaml yaml, Resource resource) &#123;\n\tint count &#x3D; 0;\n\ttry &#123;\n\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\tlogger.debug(&quot;Loading from YAML: &quot; + resource);\n\t\t&#125;\n\t\ttry (Reader reader &#x3D; new UnicodeReader(resource.getInputStream())) &#123;\n\t\t\t&#x2F;&#x2F; 在这里才会加载yaml\n\t\t\tfor (Object object : yaml.loadAll(reader)) &#123;\n\t\t\t\tif (object !&#x3D; null &amp;&amp; process(asMap(object), callback)) &#123;\n\t\t\t\t\tcount++;\n\t\t\t\t\tif (this.resolutionMethod &#x3D;&#x3D; ResolutionMethod.FIRST_FOUND) &#123;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t&#125;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t\tif (logger.isDebugEnabled()) &#123;\n\t\t\t\tlogger.debug(&quot;Loaded &quot; + count + &quot; document&quot; + (count &gt; 1 ? &quot;s&quot; : &quot;&quot;) +\n\t\t\t\t\t\t&quot; from YAML resource: &quot; + resource);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tcatch (IOException ex) &#123;\n\t\thandleProcessError(resource, ex);\n\t&#125;\n\treturn (count &gt; 0);\n&#125;</code></pre>\n<p>点进加载方法<code>loadAll</code>看一下，发现这是一个迭代器（还发现配置文件用文件流读取），里面有一个<br>全局对象<code>constructor</code>，暂时不去关心怎么来的，去重写的迭代器里面的next方法发现调用的是<code>constructor</code>对象的<code>getData()</code>方法。在点进去就是本文开头的内容了，这里就不再复述了。</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>到此，我们明白了SpringBoot读取配置文件的机制，并且了解了配置文件有一些特殊的语义需要注意。这次观察SpringBoot源码告一段落，其实在一开始就大概猜到了是哪里出了问题，但是不清楚为什么会这样，阅读完源码想明白了很多，感觉又有成长了。</p>\n","feature":true,"text":"记SpringBoot读取配置文件的坑（自定义元数据）使用的注解@ConfigurationProperties，@ConditionalOnProperty在一次日常写代码中，按着度娘写的代码去读取配置文件中的数据，发现 @ConditionalOnProperty 这个注解总...","link":"","photos":[],"count_time":{"symbolsCount":"6.4k","symbolsTime":"6 mins."},"categories":[],"tags":[{"name":"SpringBoot","slug":"SpringBoot","count":1,"path":"api/tags/SpringBoot.json"},{"name":"Java","slug":"Java","count":1,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%B0SpringBoot%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%9D%91%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%E5%85%83%E6%95%B0%E6%8D%AE%EF%BC%89\"><span class=\"toc-text\">记SpringBoot读取配置文件的坑（自定义元数据）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%88%E8%AF%B4%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">先说结论</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%97%9B%E8%8B%A6%E8%AE%B0%E5%BF%86\"><span class=\"toc-text\">痛苦记忆</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">根本原因</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"Xin_Chen","slug":"xin_chen","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"前方净空，浮标已亮，准许跃迁<br/>愿诸君武运昌盛，燃尽星空","socials":{"github":"https://github.com/hanzixin13","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"【内网穿透】FRP搭建内外穿透","uid":"debc4d6563791bdbea268a12e8990d21","slug":"【内网穿透】从零开始搭建FRP服务","date":"2022-07-07T12:35:01.000Z","updated":"2022-07-07T12:36:15.668Z","comments":true,"path":"api/articles/【内网穿透】从零开始搭建FRP服务.json","keywords":null,"cover":[],"text":"FRP搭建内外穿透1. FRP简单介绍 frp is a fast reverse proxy to help you expose a local server behind a NAT or firewall to the Internet. As of now, it su...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Linux","slug":"Linux","count":1,"path":"api/tags/Linux.json"},{"name":"FRP","slug":"FRP","count":1,"path":"api/tags/FRP.json"}],"author":{"name":"Xin_Chen","slug":"xin_chen","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"前方净空，浮标已亮，准许跃迁<br/>愿诸君武运昌盛，燃尽星空","socials":{"github":"https://github.com/hanzixin13","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"【Linux】Linux命令笔记","uid":"426935cfda214078fe347e2ba79a50b5","slug":"Linux命令笔记","date":"2022-05-27T07:27:22.000Z","updated":"2022-05-27T09:49:40.547Z","comments":true,"path":"api/articles/Linux命令笔记.json","keywords":null,"cover":null,"text":"Linux常用命令开启指定端口firewall-cmd --zone&#x3D;public --add-port&#x3D;8080&#x2F;tcp --permanent 含义： –zone #作用域 –add-port&#x3D;8080&#x2F;tcp #端口&#x2...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"linux","slug":"linux","count":1,"path":"api/tags/linux.json"}],"author":{"name":"Xin_Chen","slug":"xin_chen","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"前方净空，浮标已亮，准许跃迁<br/>愿诸君武运昌盛，燃尽星空","socials":{"github":"https://github.com/hanzixin13","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}